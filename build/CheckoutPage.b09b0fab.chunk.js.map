{"version":3,"sources":["containers/CheckoutPage/CheckoutPageSessionHelpers.js","containers/CheckoutPage/CheckoutPage.js","containers/CheckoutPage/CheckoutPage.module.css"],"names":["UUID","sdkTypes","Money","validateProperties","obj","validPropTypes","reduce","Object","entries","acc","prop","fn","prototype","hasOwnProperty","call","storeData","bookingData","bookingDates","listing","transaction","storageKey","window","sessionStorage","data","storedAt","Date","storableData","JSON","stringify","k","v","this","date","_serializedType","Decimal","decimal","replacer","setItem","storedData","checkoutPageData","getItem","parse","reviver","isFreshlySaved","moment","isAfter","subtract","isTransactionValid","id","type","attributes","TRANSITIONS","includes","lastTransition","isValidTransaction","isStoredDataValid","bookingStart","d","bookingEnd","isValidBookingDates","price","isValidListing","STORAGE_KEY","STRIPE_PI_USER_ACTIONS_DONE_STATUSES","PAY_AND_SAVE_FOR_LATER_USE","USE_SAVED_CARD","checkIsPaymentExpired","existingTransaction","txIsPaymentExpired","txIsPaymentPending","minutesBetween","lastTransitionedAt","CheckoutPageComponent","props","state","pageData","dataLoaded","submitting","stripe","onStripeInitialized","bind","loadInitialData","handlePaymentIntent","handleSubmit","fetchSpeculatedTransaction","fetchStripeCustomer","history","hasNavigatedThroughLink","action","hasDataInProps","tx","isBookingCreated","booking","listingId","transactionId","dateFromLocalToAPI","setState","handlePaymentParams","currentUser","stripeCustomerFetched","onInitiateOrder","onConfirmCardPayment","onConfirmPayment","onSendMessage","onSavePaymentMethod","speculatedTransaction","message","paymentIntent","selectedPaymentMethod","saveAfterOnetimePayment","storedTx","ensureTransaction","ensuredCurrentUser","ensureCurrentUser","ensuredStripeCustomer","ensureStripeCustomer","stripeCustomer","ensuredDefaultPaymentMethod","ensurePaymentMethodCard","defaultPaymentMethod","createdPaymentIntent","hasDefaultPaymentMethod","stripeCustomerId","stripePaymentMethodId","selectedPaymentFlow","paymentFlow","applyAsync","val","then","handlePaymentIntentCreation","funcs","x","Promise","resolve","composeAsync","fnParams","protectedData","stripePaymentIntents","order","hasPaymentIntents","Error","stripePaymentIntentClientSecret","default","card","billingDetails","stripeElementMaybe","paymentParams","payment_method","billing_details","params","orderId","status","response","errors","paymentMethodSaved","catch","e","optionalPaymentParams","paymentMethod","setupPaymentMethodForSaving","start","end","values","dispatch","formValues","name","addressLine1","addressLine2","postal","city","country","addressMaybe","address","line1","line2","postal_code","email","requestPaymentParams","res","messageSuccess","routes","routeConfiguration","initialMessageFailedToTransaction","orderDetailsPath","pathByRouteName","uuid","initialValues","findRouteByRouteName","setInitialValues","initializeOrderPage","savePaymentMethodFailed","removeItem","push","err","console","error","onRetrievePaymentIntent","scrollingDisabled","speculateTransactionInProgress","speculateTransactionError","speculatedTransactionMaybe","initiateOrderError","confirmPaymentError","intl","confirmCardPaymentError","retrievePaymentIntentError","listingNotFound","isTransactionInitiateListingNotFoundError","isLoading","currentListing","ensureListing","currentAuthor","ensureUser","author","listingTitle","title","formatMessage","pageProps","topbar","className","css","home","logoMobile","format","logoDesktop","alt","isOwnListing","hasListingAndAuthor","hasBookingDates","hasRequiredData","txBooking","ensureBooking","breakdown","bookingBreakdown","userRole","unitType","config","bookingUnitType","dateType","DATE_TYPE_DATE","isPaymentExpired","showPaymentForm","firstImage","images","length","listingLink","slug","createSlug","isAmountTooLowError","isTransactionInitiateAmountTooLowError","isChargeDisabledError","isTransactionChargeDisabledError","isBookingTimeNotAvailableError","isTransactionInitiateBookingTimeNotAvailableError","stripeErrors","transactionInitiateOrderStripeErrors","initiateOrderErrorMessage","listingNotFoundErrorMessage","notFoundError","orderError","stripeErrorsAsString","join","speculateTransactionErrorMessage","speculateError","speculateErrorMessage","isTransactionInitiateMissingStripeAccountError","isTransactionZeroPaymentError","isNightly","LINE_ITEM_NIGHT","isDaily","LINE_ITEM_DAY","unitTranslationKey","formattedPrice","formatMoney","detailsSubTitle","showInitialMessageInput","TRANSITION_ENQUIRE","userName","profile","firstName","lastName","hasPaymentIntentUserActionsDone","initalValuesForStripePayment","contentContainer","aspectWrapper","rootClassName","rootForImage","image","variants","classNames","avatarWrapper","avatarMobile","user","disableProfileLink","bookListingContainer","heading","displayName","priceBreakdownContainer","paymentContainer","paymentForm","onSubmit","inProgress","formId","paymentInfo","authorDisplayName","hasHandledCardPayment","loadingData","detailsContainerDesktop","detailsAspectWrapper","detailsHeadings","detailsTitle","detailsSubtitle","Component","defaultProps","CheckoutPage","compose","withRouter","connect","isScrollingDisabled","speculateTransaction","initiateOrder","retrievePaymentIntent","confirmCardPayment","confirmPayment","sendMessage","savePaymentMethod","injectIntl","saveToSessionStorage","module","exports"],"mappings":"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","file":"CheckoutPage.b09b0fab.chunk.js","sourcesContent":["/**\n * CheckoutPage starts payment process and therefore it will get data from ListingPage\n * (booking dates, listing data, and all the other data that affects to booking decision).\n * This data is saved to Session Store which only exists while the browsing session exists -\n * e.g. tab is open. (Session Store is not related to session cookies.)\n */\nimport moment from 'moment';\nimport reduce from 'lodash/reduce';\nimport Decimal from 'decimal.js';\nimport { types as sdkTypes } from '../../util/sdkLoader';\nimport { TRANSITIONS } from '../../util/transaction';\n\nconst { UUID, Money } = sdkTypes;\n\n// Validate that given 'obj' has all the keys of defined by validPropTypes parameter\n// and values must pass related test-value-format function.\nconst validateProperties = (obj, validPropTypes) => {\n  return reduce(\n    Object.entries(validPropTypes),\n    (acc, [prop, fn]) => {\n      if (Object.prototype.hasOwnProperty.call(obj, prop) && fn(obj[prop])) {\n        return acc;\n      }\n      return false;\n    },\n    true\n  );\n};\n\n// Validate content of booking dates object received from SessionStore\nexport const isValidBookingDates = bookingDates => {\n  const props = {\n    bookingStart: d => d instanceof Date,\n    bookingEnd: d => d instanceof Date,\n  };\n  return validateProperties(bookingDates, props);\n};\n\n// Validate content of listing object received from SessionStore.\n// Currently only id & attributes.price are needed.\nexport const isValidListing = listing => {\n  const props = {\n    id: id => id instanceof UUID,\n    attributes: v => {\n      return typeof v === 'object' && v.price instanceof Money;\n    },\n  };\n  return validateProperties(listing, props);\n};\n\n// Validate content of an transaction received from SessionStore.\n// An id is required and the last transition needs to be one of the known transitions\nexport const isValidTransaction = transaction => {\n  const props = {\n    id: id => id instanceof UUID,\n    type: type => type === 'transaction',\n    attributes: v => {\n      return typeof v === 'object' && TRANSITIONS.includes(v.lastTransition);\n    },\n  };\n  return validateProperties(transaction, props);\n};\n\n// Stores given bookingDates and listing to sessionStorage\nexport const storeData = (bookingData, bookingDates, listing, transaction, storageKey) => {\n  if (window && window.sessionStorage && listing && bookingDates && bookingData) {\n    const data = {\n      bookingData,\n      bookingDates,\n      listing,\n      transaction,\n      storedAt: new Date(),\n    };\n\n    const replacer = function(k, v) {\n      if (this[k] instanceof Date) {\n        return { date: v, _serializedType: 'SerializableDate' };\n      }\n      if (this[k] instanceof Decimal) {\n        return { decimal: v, _serializedType: 'SerializableDecimal' };\n      }\n      return sdkTypes.replacer(k, v);\n    };\n\n    const storableData = JSON.stringify(data, replacer);\n    window.sessionStorage.setItem(storageKey, storableData);\n  }\n};\n\n// Get stored data\nexport const storedData = storageKey => {\n  if (window && window.sessionStorage) {\n    const checkoutPageData = window.sessionStorage.getItem(storageKey);\n\n    const reviver = (k, v) => {\n      if (v && typeof v === 'object' && v._serializedType === 'SerializableDate') {\n        // Dates are expected to be stored as:\n        // { date: new Date(), _serializedType: 'SerializableDate' }\n        return new Date(v.date);\n      } else if (v && typeof v === 'object' && v._serializedType === 'SerializableDecimal') {\n        // Decimals are expected to be stored as:\n        // { decimal: v, _serializedType: 'SerializableDecimal' }\n        return new Decimal(v.decimal);\n      }\n      return sdkTypes.reviver(k, v);\n    };\n\n    const { bookingData, bookingDates, listing, transaction, storedAt } = checkoutPageData\n      ? JSON.parse(checkoutPageData, reviver)\n      : {};\n\n    // If sessionStore contains freshly saved data (max 1 day old), use it\n    const isFreshlySaved = storedAt\n      ? moment(storedAt).isAfter(moment().subtract(1, 'days'))\n      : false;\n\n    // resolve transaction as valid if it is missing\n    const isTransactionValid = !!transaction ? isValidTransaction(transaction) : true;\n\n    const isStoredDataValid =\n      isFreshlySaved &&\n      isValidBookingDates(bookingDates) &&\n      isValidListing(listing) &&\n      isTransactionValid;\n\n    if (isStoredDataValid) {\n      return { bookingData, bookingDates, listing, transaction };\n    }\n  }\n  return {};\n};\n\nexport const clearData = storageKey => {\n  if (window && window.sessionStorage) {\n    window.sessionStorage.removeItem(storageKey);\n  }\n};\n","import React, { Component } from 'react';\nimport { bool, func, instanceOf, object, oneOfType, shape, string } from 'prop-types';\nimport { compose } from 'redux';\nimport { connect } from 'react-redux';\nimport { FormattedMessage, injectIntl, intlShape } from '../../util/reactIntl';\nimport { withRouter } from 'react-router-dom';\nimport classNames from 'classnames';\nimport config from '../../config';\nimport routeConfiguration from '../../routeConfiguration';\nimport { pathByRouteName, findRouteByRouteName } from '../../util/routes';\nimport { propTypes, LINE_ITEM_NIGHT, LINE_ITEM_DAY, DATE_TYPE_DATE } from '../../util/types';\nimport {\n  ensureListing,\n  ensureCurrentUser,\n  ensureUser,\n  ensureTransaction,\n  ensureBooking,\n  ensureStripeCustomer,\n  ensurePaymentMethodCard,\n} from '../../util/data';\nimport { dateFromLocalToAPI, minutesBetween } from '../../util/dates';\nimport { createSlug } from '../../util/urlHelpers';\nimport {\n  isTransactionInitiateAmountTooLowError,\n  isTransactionInitiateListingNotFoundError,\n  isTransactionInitiateMissingStripeAccountError,\n  isTransactionInitiateBookingTimeNotAvailableError,\n  isTransactionChargeDisabledError,\n  isTransactionZeroPaymentError,\n  transactionInitiateOrderStripeErrors,\n} from '../../util/errors';\nimport { formatMoney } from '../../util/currency';\nimport { TRANSITION_ENQUIRE, txIsPaymentPending, txIsPaymentExpired } from '../../util/transaction';\nimport {\n  AvatarMedium,\n  BookingBreakdown,\n  Logo,\n  NamedLink,\n  NamedRedirect,\n  Page,\n  ResponsiveImage,\n} from '../../components';\nimport { StripePaymentForm } from '../../forms';\nimport { isScrollingDisabled } from '../../ducks/UI.duck';\nimport { confirmCardPayment, retrievePaymentIntent } from '../../ducks/stripe.duck';\nimport { savePaymentMethod } from '../../ducks/paymentMethods.duck';\n\nimport {\n  initiateOrder,\n  setInitialValues,\n  speculateTransaction,\n  stripeCustomer,\n  confirmPayment,\n  sendMessage,\n} from './CheckoutPage.duck';\nimport { storeData, storedData, clearData } from './CheckoutPageSessionHelpers';\nimport css from './CheckoutPage.module.css';\n\nconst STORAGE_KEY = 'CheckoutPage';\n\n// Stripe PaymentIntent statuses, where user actions are already completed\n// https://stripe.com/docs/payments/payment-intents/status\nconst STRIPE_PI_USER_ACTIONS_DONE_STATUSES = ['processing', 'requires_capture', 'succeeded'];\n\n// Payment charge options\nconst ONETIME_PAYMENT = 'ONETIME_PAYMENT';\nconst PAY_AND_SAVE_FOR_LATER_USE = 'PAY_AND_SAVE_FOR_LATER_USE';\nconst USE_SAVED_CARD = 'USE_SAVED_CARD';\n\nconst paymentFlow = (selectedPaymentMethod, saveAfterOnetimePayment) => {\n  // Payment mode could be 'replaceCard', but without explicit saveAfterOnetimePayment flag,\n  // we'll handle it as one-time payment\n  return selectedPaymentMethod === 'defaultCard'\n    ? USE_SAVED_CARD\n    : saveAfterOnetimePayment\n    ? PAY_AND_SAVE_FOR_LATER_USE\n    : ONETIME_PAYMENT;\n};\n\nconst initializeOrderPage = (initialValues, routes, dispatch) => {\n  const OrderPage = findRouteByRouteName('OrderDetailsPage', routes);\n\n  // Transaction is already created, but if the initial message\n  // sending failed, we tell it to the OrderDetailsPage.\n  dispatch(OrderPage.setInitialValues(initialValues));\n};\n\nconst checkIsPaymentExpired = existingTransaction => {\n  return txIsPaymentExpired(existingTransaction)\n    ? true\n    : txIsPaymentPending(existingTransaction)\n    ? minutesBetween(existingTransaction.attributes.lastTransitionedAt, new Date()) >= 15\n    : false;\n};\n\nexport class CheckoutPageComponent extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      pageData: {},\n      dataLoaded: false,\n      submitting: false,\n    };\n    this.stripe = null;\n\n    this.onStripeInitialized = this.onStripeInitialized.bind(this);\n    this.loadInitialData = this.loadInitialData.bind(this);\n    this.handlePaymentIntent = this.handlePaymentIntent.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  componentDidMount() {\n    if (window) {\n      this.loadInitialData();\n    }\n  }\n\n  /**\n   * Load initial data for the page\n   *\n   * Since the data for the checkout is not passed in the URL (there\n   * might be lots of options in the future), we must pass in the data\n   * some other way. Currently the ListingPage sets the initial data\n   * for the CheckoutPage's Redux store.\n   *\n   * For some cases (e.g. a refresh in the CheckoutPage), the Redux\n   * store is empty. To handle that case, we store the received data\n   * to window.sessionStorage and read it from there if no props from\n   * the store exist.\n   *\n   * This function also sets of fetching the speculative transaction\n   * based on this initial data.\n   */\n  loadInitialData() {\n    const {\n      bookingData,\n      bookingDates,\n      listing,\n      transaction,\n      fetchSpeculatedTransaction,\n      fetchStripeCustomer,\n      history,\n    } = this.props;\n\n    // Fetch currentUser with stripeCustomer entity\n    // Note: since there's need for data loading in \"componentWillMount\" function,\n    //       this is added here instead of loadData static function.\n    fetchStripeCustomer();\n\n    // Browser's back navigation should not rewrite data in session store.\n    // Action is 'POP' on both history.back() and page refresh cases.\n    // Action is 'PUSH' when user has directed through a link\n    // Action is 'REPLACE' when user has directed through login/signup process\n    const hasNavigatedThroughLink = history.action === 'PUSH' || history.action === 'REPLACE';\n\n    const hasDataInProps = !!(bookingData && bookingDates && listing) && hasNavigatedThroughLink;\n    if (hasDataInProps) {\n      // Store data only if data is passed through props and user has navigated through a link.\n      storeData(bookingData, bookingDates, listing, transaction, STORAGE_KEY);\n    }\n\n    // NOTE: stored data can be empty if user has already successfully completed transaction.\n    const pageData = hasDataInProps\n      ? { bookingData, bookingDates, listing, transaction }\n      : storedData(STORAGE_KEY);\n\n    // Check if a booking is already created according to stored data.\n    const tx = pageData ? pageData.transaction : null;\n    const isBookingCreated = tx && tx.booking && tx.booking.id;\n\n    const shouldFetchSpeculatedTransaction =\n      pageData &&\n      pageData.listing &&\n      pageData.listing.id &&\n      pageData.bookingData &&\n      pageData.bookingDates &&\n      pageData.bookingDates.bookingStart &&\n      pageData.bookingDates.bookingEnd &&\n      !isBookingCreated;\n\n    if (shouldFetchSpeculatedTransaction) {\n      const listingId = pageData.listing.id;\n      const transactionId = tx ? tx.id : null;\n      const { bookingStart, bookingEnd } = pageData.bookingDates;\n\n      // Convert picked date to date that will be converted on the API as\n      // a noon of correct year-month-date combo in UTC\n      const bookingStartForAPI = dateFromLocalToAPI(bookingStart);\n      const bookingEndForAPI = dateFromLocalToAPI(bookingEnd);\n\n      // Fetch speculated transaction for showing price in booking breakdown\n      // NOTE: if unit type is line-item/units, quantity needs to be added.\n      // The way to pass it to checkout page is through pageData.bookingData\n      fetchSpeculatedTransaction(\n        {\n          listingId,\n          bookingStart: bookingStartForAPI,\n          bookingEnd: bookingEndForAPI,\n        },\n        transactionId\n      );\n    }\n\n    this.setState({ pageData: pageData || {}, dataLoaded: true });\n  }\n\n  handlePaymentIntent(handlePaymentParams) {\n    const {\n      currentUser,\n      stripeCustomerFetched,\n      onInitiateOrder,\n      onConfirmCardPayment,\n      onConfirmPayment,\n      onSendMessage,\n      onSavePaymentMethod,\n    } = this.props;\n    const {\n      pageData,\n      speculatedTransaction,\n      message,\n      paymentIntent,\n      selectedPaymentMethod,\n      saveAfterOnetimePayment,\n    } = handlePaymentParams;\n    const storedTx = ensureTransaction(pageData.transaction);\n\n    const ensuredCurrentUser = ensureCurrentUser(currentUser);\n    const ensuredStripeCustomer = ensureStripeCustomer(ensuredCurrentUser.stripeCustomer);\n    const ensuredDefaultPaymentMethod = ensurePaymentMethodCard(\n      ensuredStripeCustomer.defaultPaymentMethod\n    );\n\n    let createdPaymentIntent = null;\n\n    const hasDefaultPaymentMethod = !!(\n      stripeCustomerFetched &&\n      ensuredStripeCustomer.attributes.stripeCustomerId &&\n      ensuredDefaultPaymentMethod.id\n    );\n    const stripePaymentMethodId = hasDefaultPaymentMethod\n      ? ensuredDefaultPaymentMethod.attributes.stripePaymentMethodId\n      : null;\n\n    const selectedPaymentFlow = paymentFlow(selectedPaymentMethod, saveAfterOnetimePayment);\n\n    // Step 1: initiate order by requesting payment from Marketplace API\n    const fnRequestPayment = fnParams => {\n      // fnParams should be { listingId, bookingStart, bookingEnd }\n      const hasPaymentIntents =\n        storedTx.attributes.protectedData && storedTx.attributes.protectedData.stripePaymentIntents;\n\n      // If paymentIntent exists, order has been initiated previously.\n      return hasPaymentIntents ? Promise.resolve(storedTx) : onInitiateOrder(fnParams, storedTx.id);\n    };\n\n    // Step 2: pay using Stripe SDK\n    const fnConfirmCardPayment = fnParams => {\n      // fnParams should be returned transaction entity\n\n      const order = ensureTransaction(fnParams);\n      if (order.id) {\n        // Store order.\n        const { bookingData, bookingDates, listing } = pageData;\n        storeData(bookingData, bookingDates, listing, order, STORAGE_KEY);\n        this.setState({ pageData: { ...pageData, transaction: order } });\n      }\n\n      const hasPaymentIntents =\n        order.attributes.protectedData && order.attributes.protectedData.stripePaymentIntents;\n\n      if (!hasPaymentIntents) {\n        throw new Error(\n          `Missing StripePaymentIntents key in transaction's protectedData. Check that your transaction process is configured to use payment intents.`\n        );\n      }\n\n      const { stripePaymentIntentClientSecret } = hasPaymentIntents\n        ? order.attributes.protectedData.stripePaymentIntents.default\n        : null;\n\n      const { stripe, card, billingDetails, paymentIntent } = handlePaymentParams;\n      const stripeElementMaybe = selectedPaymentFlow !== USE_SAVED_CARD ? { card } : {};\n\n      // Note: payment_method could be set here for USE_SAVED_CARD flow.\n      // { payment_method: stripePaymentMethodId }\n      // However, we have set it already on API side, when PaymentIntent was created.\n      const paymentParams =\n        selectedPaymentFlow !== USE_SAVED_CARD\n          ? {\n              payment_method: {\n                billing_details: billingDetails,\n                card: card,\n              },\n            }\n          : {};\n\n      const params = {\n        stripePaymentIntentClientSecret,\n        orderId: order.id,\n        stripe,\n        ...stripeElementMaybe,\n        paymentParams,\n      };\n\n      // If paymentIntent status is not waiting user action,\n      // confirmCardPayment has been called previously.\n      const hasPaymentIntentUserActionsDone =\n        paymentIntent && STRIPE_PI_USER_ACTIONS_DONE_STATUSES.includes(paymentIntent.status);\n      return hasPaymentIntentUserActionsDone\n        ? Promise.resolve({ transactionId: order.id, paymentIntent })\n        : onConfirmCardPayment(params);\n    };\n\n    // Step 3: complete order by confirming payment to Marketplace API\n    // Parameter should contain { paymentIntent, transactionId } returned in step 2\n    const fnConfirmPayment = fnParams => {\n      createdPaymentIntent = fnParams.paymentIntent;\n      return onConfirmPayment(fnParams);\n    };\n\n    // Step 4: send initial message\n    const fnSendMessage = fnParams => {\n      return onSendMessage({ ...fnParams, message });\n    };\n\n    // Step 5: optionally save card as defaultPaymentMethod\n    const fnSavePaymentMethod = fnParams => {\n      const pi = createdPaymentIntent || paymentIntent;\n\n      if (selectedPaymentFlow === PAY_AND_SAVE_FOR_LATER_USE) {\n        return onSavePaymentMethod(ensuredStripeCustomer, pi.payment_method)\n          .then(response => {\n            if (response.errors) {\n              return { ...fnParams, paymentMethodSaved: false };\n            }\n            return { ...fnParams, paymentMethodSaved: true };\n          })\n          .catch(e => {\n            // Real error cases are catched already in paymentMethods page.\n            return { ...fnParams, paymentMethodSaved: false };\n          });\n      } else {\n        return Promise.resolve({ ...fnParams, paymentMethodSaved: true });\n      }\n    };\n\n    // Here we create promise calls in sequence\n    // This is pretty much the same as:\n    // fnRequestPayment({...initialParams})\n    //   .then(result => fnConfirmCardPayment({...result}))\n    //   .then(result => fnConfirmPayment({...result}))\n    const applyAsync = (acc, val) => acc.then(val);\n    const composeAsync = (...funcs) => x => funcs.reduce(applyAsync, Promise.resolve(x));\n    const handlePaymentIntentCreation = composeAsync(\n      fnRequestPayment,\n      fnConfirmCardPayment,\n      fnConfirmPayment,\n      fnSendMessage,\n      fnSavePaymentMethod\n    );\n\n    // Create order aka transaction\n    // NOTE: if unit type is line-item/units, quantity needs to be added.\n    // The way to pass it to checkout page is through pageData.bookingData\n    const tx = speculatedTransaction ? speculatedTransaction : storedTx;\n\n    // Note: optionalPaymentParams contains Stripe paymentMethod,\n    // but that can also be passed on Step 2\n    // stripe.confirmCardPayment(stripe, { payment_method: stripePaymentMethodId })\n    const optionalPaymentParams =\n      selectedPaymentFlow === USE_SAVED_CARD && hasDefaultPaymentMethod\n        ? { paymentMethod: stripePaymentMethodId }\n        : selectedPaymentFlow === PAY_AND_SAVE_FOR_LATER_USE\n        ? { setupPaymentMethodForSaving: true }\n        : {};\n\n    const orderParams = {\n      listingId: pageData.listing.id,\n      bookingStart: tx.booking.attributes.start,\n      bookingEnd: tx.booking.attributes.end,\n      ...optionalPaymentParams,\n    };\n\n    return handlePaymentIntentCreation(orderParams);\n  }\n\n  handleSubmit(values) {\n    if (this.state.submitting) {\n      return;\n    }\n    this.setState({ submitting: true });\n\n    const { history, speculatedTransaction, currentUser, paymentIntent, dispatch } = this.props;\n    const { card, message, paymentMethod, formValues } = values;\n    const {\n      name,\n      addressLine1,\n      addressLine2,\n      postal,\n      city,\n      state,\n      country,\n      saveAfterOnetimePayment,\n    } = formValues;\n\n    // Billing address is recommended.\n    // However, let's not assume that <StripePaymentAddress> data is among formValues.\n    // Read more about this from Stripe's docs\n    // https://stripe.com/docs/stripe-js/reference#stripe-handle-card-payment-no-element\n    const addressMaybe =\n      addressLine1 && postal\n        ? {\n            address: {\n              city: city,\n              country: country,\n              line1: addressLine1,\n              line2: addressLine2,\n              postal_code: postal,\n              state: state,\n            },\n          }\n        : {};\n    const billingDetails = {\n      name,\n      email: ensureCurrentUser(currentUser).attributes.email,\n      ...addressMaybe,\n    };\n\n    const requestPaymentParams = {\n      pageData: this.state.pageData,\n      speculatedTransaction,\n      stripe: this.stripe,\n      card,\n      billingDetails,\n      message,\n      paymentIntent,\n      selectedPaymentMethod: paymentMethod,\n      saveAfterOnetimePayment: !!saveAfterOnetimePayment,\n    };\n\n    this.handlePaymentIntent(requestPaymentParams)\n      .then(res => {\n        const { orderId, messageSuccess, paymentMethodSaved } = res;\n        this.setState({ submitting: false });\n\n        const routes = routeConfiguration();\n        const initialMessageFailedToTransaction = messageSuccess ? null : orderId;\n        const orderDetailsPath = pathByRouteName('OrderDetailsPage', routes, { id: orderId.uuid });\n        const initialValues = {\n          initialMessageFailedToTransaction,\n          savePaymentMethodFailed: !paymentMethodSaved,\n        };\n\n        initializeOrderPage(initialValues, routes, dispatch);\n        clearData(STORAGE_KEY);\n        history.push(orderDetailsPath);\n      })\n      .catch(err => {\n        console.error(err);\n        this.setState({ submitting: false });\n      });\n  }\n\n  onStripeInitialized(stripe) {\n    this.stripe = stripe;\n\n    const { paymentIntent, onRetrievePaymentIntent } = this.props;\n    const tx = this.state.pageData ? this.state.pageData.transaction : null;\n\n    // We need to get up to date PI, if booking is created but payment is not expired.\n    const shouldFetchPaymentIntent =\n      this.stripe &&\n      !paymentIntent &&\n      tx &&\n      tx.id &&\n      tx.booking &&\n      tx.booking.id &&\n      txIsPaymentPending(tx) &&\n      !checkIsPaymentExpired(tx);\n\n    if (shouldFetchPaymentIntent) {\n      const { stripePaymentIntentClientSecret } =\n        tx.attributes.protectedData && tx.attributes.protectedData.stripePaymentIntents\n          ? tx.attributes.protectedData.stripePaymentIntents.default\n          : {};\n\n      // Fetch up to date PaymentIntent from Stripe\n      onRetrievePaymentIntent({ stripe, stripePaymentIntentClientSecret });\n    }\n  }\n\n  render() {\n    const {\n      scrollingDisabled,\n      speculateTransactionInProgress,\n      speculateTransactionError,\n      speculatedTransaction: speculatedTransactionMaybe,\n      initiateOrderError,\n      confirmPaymentError,\n      intl,\n      params,\n      currentUser,\n      confirmCardPaymentError,\n      paymentIntent,\n      retrievePaymentIntentError,\n      stripeCustomerFetched,\n    } = this.props;\n\n    // Since the listing data is already given from the ListingPage\n    // and stored to handle refreshes, it might not have the possible\n    // deleted or closed information in it. If the transaction\n    // initiate or the speculative initiate fail due to the listing\n    // being deleted or closec, we should dig the information from the\n    // errors and not the listing data.\n    const listingNotFound =\n      isTransactionInitiateListingNotFoundError(speculateTransactionError) ||\n      isTransactionInitiateListingNotFoundError(initiateOrderError);\n\n    const isLoading = !this.state.dataLoaded || speculateTransactionInProgress;\n\n    const { listing, bookingDates, transaction } = this.state.pageData;\n    const existingTransaction = ensureTransaction(transaction);\n    const speculatedTransaction = ensureTransaction(speculatedTransactionMaybe, {}, null);\n    const currentListing = ensureListing(listing);\n    const currentAuthor = ensureUser(currentListing.author);\n\n    const listingTitle = currentListing.attributes.title;\n    const title = intl.formatMessage({ id: 'CheckoutPage.title' }, { listingTitle });\n\n    const pageProps = { title, scrollingDisabled };\n    const topbar = (\n      <div className={css.topbar}>\n        <NamedLink className={css.home} name=\"LandingPage\">\n          <Logo\n            className={css.logoMobile}\n            title={intl.formatMessage({ id: 'CheckoutPage.goToLandingPage' })}\n            format=\"mobile\"\n          />\n          <Logo\n            className={css.logoDesktop}\n            alt={intl.formatMessage({ id: 'CheckoutPage.goToLandingPage' })}\n            format=\"desktop\"\n          />\n        </NamedLink>\n      </div>\n    );\n\n    if (isLoading) {\n      return <Page {...pageProps}>{topbar}</Page>;\n    }\n\n    const isOwnListing =\n      currentUser &&\n      currentUser.id &&\n      currentAuthor &&\n      currentAuthor.id &&\n      currentAuthor.id.uuid === currentUser.id.uuid;\n\n    const hasListingAndAuthor = !!(currentListing.id && currentAuthor.id);\n    const hasBookingDates = !!(\n      bookingDates &&\n      bookingDates.bookingStart &&\n      bookingDates.bookingEnd\n    );\n    const hasRequiredData = hasListingAndAuthor && hasBookingDates;\n    const canShowPage = hasRequiredData && !isOwnListing;\n    const shouldRedirect = !isLoading && !canShowPage;\n\n    // Redirect back to ListingPage if data is missing.\n    // Redirection must happen before any data format error is thrown (e.g. wrong currency)\n    if (shouldRedirect) {\n      // eslint-disable-next-line no-console\n      console.error('Missing or invalid data for checkout, redirecting back to listing page.', {\n        transaction: speculatedTransaction,\n        bookingDates,\n        listing,\n      });\n      return <NamedRedirect name=\"ListingPage\" params={params} />;\n    }\n\n    // Show breakdown only when speculated transaction and booking are loaded\n    // (i.e. have an id)\n    const tx = existingTransaction.booking ? existingTransaction : speculatedTransaction;\n    const txBooking = ensureBooking(tx.booking);\n    const breakdown =\n      tx.id && txBooking.id ? (\n        <BookingBreakdown\n          className={css.bookingBreakdown}\n          userRole=\"customer\"\n          unitType={config.bookingUnitType}\n          transaction={tx}\n          booking={txBooking}\n          dateType={DATE_TYPE_DATE}\n        />\n      ) : null;\n\n    const isPaymentExpired = checkIsPaymentExpired(existingTransaction);\n    const hasDefaultPaymentMethod = !!(\n      stripeCustomerFetched &&\n      ensureStripeCustomer(currentUser.stripeCustomer).attributes.stripeCustomerId &&\n      ensurePaymentMethodCard(currentUser.stripeCustomer.defaultPaymentMethod).id\n    );\n\n    // Allow showing page when currentUser is still being downloaded,\n    // but show payment form only when user info is loaded.\n    const showPaymentForm = !!(\n      currentUser &&\n      hasRequiredData &&\n      !listingNotFound &&\n      !initiateOrderError &&\n      !speculateTransactionError &&\n      !retrievePaymentIntentError &&\n      !isPaymentExpired\n    );\n\n    const firstImage =\n      currentListing.images && currentListing.images.length > 0 ? currentListing.images[0] : null;\n\n    const listingLink = (\n      <NamedLink\n        name=\"ListingPage\"\n        params={{ id: currentListing.id.uuid, slug: createSlug(listingTitle) }}\n      >\n        <FormattedMessage id=\"CheckoutPage.errorlistingLinkText\" />\n      </NamedLink>\n    );\n\n    const isAmountTooLowError = isTransactionInitiateAmountTooLowError(initiateOrderError);\n    const isChargeDisabledError = isTransactionChargeDisabledError(initiateOrderError);\n    const isBookingTimeNotAvailableError = isTransactionInitiateBookingTimeNotAvailableError(\n      initiateOrderError\n    );\n    const stripeErrors = transactionInitiateOrderStripeErrors(initiateOrderError);\n\n    let initiateOrderErrorMessage = null;\n    let listingNotFoundErrorMessage = null;\n\n    if (listingNotFound) {\n      listingNotFoundErrorMessage = (\n        <p className={css.notFoundError}>\n          <FormattedMessage id=\"CheckoutPage.listingNotFoundError\" />\n        </p>\n      );\n    } else if (isAmountTooLowError) {\n      initiateOrderErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.initiateOrderAmountTooLow\" />\n        </p>\n      );\n    } else if (isBookingTimeNotAvailableError) {\n      initiateOrderErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.bookingTimeNotAvailableMessage\" />\n        </p>\n      );\n    } else if (isChargeDisabledError) {\n      initiateOrderErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.chargeDisabledMessage\" />\n        </p>\n      );\n    } else if (stripeErrors && stripeErrors.length > 0) {\n      // NOTE: Error messages from Stripes are not part of translations.\n      // By default they are in English.\n      const stripeErrorsAsString = stripeErrors.join(', ');\n      initiateOrderErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage\n            id=\"CheckoutPage.initiateOrderStripeError\"\n            values={{ stripeErrors: stripeErrorsAsString }}\n          />\n        </p>\n      );\n    } else if (initiateOrderError) {\n      // Generic initiate order error\n      initiateOrderErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.initiateOrderError\" values={{ listingLink }} />\n        </p>\n      );\n    }\n\n    const speculateTransactionErrorMessage = speculateTransactionError ? (\n      <p className={css.speculateError}>\n        <FormattedMessage id=\"CheckoutPage.speculateTransactionError\" />\n      </p>\n    ) : null;\n    let speculateErrorMessage = null;\n\n    if (isTransactionInitiateMissingStripeAccountError(speculateTransactionError)) {\n      speculateErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.providerStripeAccountMissingError\" />\n        </p>\n      );\n    } else if (isTransactionInitiateBookingTimeNotAvailableError(speculateTransactionError)) {\n      speculateErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.bookingTimeNotAvailableMessage\" />\n        </p>\n      );\n    } else if (isTransactionZeroPaymentError(speculateTransactionError)) {\n      speculateErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.initiateOrderAmountTooLow\" />\n        </p>\n      );\n    } else if (speculateTransactionError) {\n      speculateErrorMessage = (\n        <p className={css.orderError}>\n          <FormattedMessage id=\"CheckoutPage.speculateFailedMessage\" />\n        </p>\n      );\n    }\n\n    const unitType = config.bookingUnitType;\n    const isNightly = unitType === LINE_ITEM_NIGHT;\n    const isDaily = unitType === LINE_ITEM_DAY;\n\n    const unitTranslationKey = isNightly\n      ? 'CheckoutPage.perNight'\n      : isDaily\n      ? 'CheckoutPage.perDay'\n      : 'CheckoutPage.perUnit';\n\n    const price = currentListing.attributes.price;\n    const formattedPrice = formatMoney(intl, price);\n    const detailsSubTitle = `${formattedPrice} ${intl.formatMessage({ id: unitTranslationKey })}`;\n\n    const showInitialMessageInput = !(\n      existingTransaction && existingTransaction.attributes.lastTransition === TRANSITION_ENQUIRE\n    );\n\n    // Get first and last name of the current user and use it in the StripePaymentForm to autofill the name field\n    const userName =\n      currentUser && currentUser.attributes\n        ? `${currentUser.attributes.profile.firstName} ${currentUser.attributes.profile.lastName}`\n        : null;\n\n    // If paymentIntent status is not waiting user action,\n    // confirmCardPayment has been called previously.\n    const hasPaymentIntentUserActionsDone =\n      paymentIntent && STRIPE_PI_USER_ACTIONS_DONE_STATUSES.includes(paymentIntent.status);\n\n    // If your marketplace works mostly in one country you can use initial values to select country automatically\n    // e.g. {country: 'FI'}\n\n    const initalValuesForStripePayment = { name: userName };\n\n    return (\n      <Page {...pageProps}>\n        {topbar}\n        <div className={css.contentContainer}>\n          <div className={css.aspectWrapper}>\n            <ResponsiveImage\n              rootClassName={css.rootForImage}\n              alt={listingTitle}\n              image={firstImage}\n              variants={['landscape-crop', 'landscape-crop2x']}\n            />\n          </div>\n          <div className={classNames(css.avatarWrapper, css.avatarMobile)}>\n            <AvatarMedium user={currentAuthor} disableProfileLink />\n          </div>\n          <div className={css.bookListingContainer}>\n            <div className={css.heading}>\n              <h1 className={css.title}>{title}</h1>\n              <div className={css.author}>\n                <FormattedMessage\n                  id=\"CheckoutPage.hostedBy\"\n                  values={{ name: currentAuthor.attributes.profile.displayName }}\n                />\n              </div>\n            </div>\n\n            <div className={css.priceBreakdownContainer}>\n              {speculateTransactionErrorMessage}\n              {breakdown}\n            </div>\n\n            <section className={css.paymentContainer}>\n              {initiateOrderErrorMessage}\n              {listingNotFoundErrorMessage}\n              {speculateErrorMessage}\n              {retrievePaymentIntentError ? (\n                <p className={css.orderError}>\n                  <FormattedMessage\n                    id=\"CheckoutPage.retrievingStripePaymentIntentFailed\"\n                    values={{ listingLink }}\n                  />\n                </p>\n              ) : null}\n              {showPaymentForm ? (\n                <StripePaymentForm\n                  className={css.paymentForm}\n                  onSubmit={this.handleSubmit}\n                  inProgress={this.state.submitting}\n                  formId=\"CheckoutPagePaymentForm\"\n                  paymentInfo={intl.formatMessage({ id: 'CheckoutPage.paymentInfo' })}\n                  authorDisplayName={currentAuthor.attributes.profile.displayName}\n                  showInitialMessageInput={showInitialMessageInput}\n                  initialValues={initalValuesForStripePayment}\n                  initiateOrderError={initiateOrderError}\n                  confirmCardPaymentError={confirmCardPaymentError}\n                  confirmPaymentError={confirmPaymentError}\n                  hasHandledCardPayment={hasPaymentIntentUserActionsDone}\n                  loadingData={!stripeCustomerFetched}\n                  defaultPaymentMethod={\n                    hasDefaultPaymentMethod ? currentUser.stripeCustomer.defaultPaymentMethod : null\n                  }\n                  paymentIntent={paymentIntent}\n                  onStripeInitialized={this.onStripeInitialized}\n                />\n              ) : null}\n              {isPaymentExpired ? (\n                <p className={css.orderError}>\n                  <FormattedMessage\n                    id=\"CheckoutPage.paymentExpiredMessage\"\n                    values={{ listingLink }}\n                  />\n                </p>\n              ) : null}\n            </section>\n          </div>\n\n          <div className={css.detailsContainerDesktop}>\n            <div className={css.detailsAspectWrapper}>\n              <ResponsiveImage\n                rootClassName={css.rootForImage}\n                alt={listingTitle}\n                image={firstImage}\n                variants={['landscape-crop', 'landscape-crop2x']}\n              />\n            </div>\n            <div className={css.avatarWrapper}>\n              <AvatarMedium user={currentAuthor} disableProfileLink />\n            </div>\n            <div className={css.detailsHeadings}>\n              <h2 className={css.detailsTitle}>{listingTitle}</h2>\n              <p className={css.detailsSubtitle}>{detailsSubTitle}</p>\n            </div>\n            {speculateTransactionErrorMessage}\n            {breakdown}\n          </div>\n        </div>\n      </Page>\n    );\n  }\n}\n\nCheckoutPageComponent.defaultProps = {\n  initiateOrderError: null,\n  confirmPaymentError: null,\n  listing: null,\n  bookingData: {},\n  bookingDates: null,\n  speculateTransactionError: null,\n  speculatedTransaction: null,\n  transaction: null,\n  currentUser: null,\n  paymentIntent: null,\n};\n\nCheckoutPageComponent.propTypes = {\n  scrollingDisabled: bool.isRequired,\n  listing: propTypes.listing,\n  bookingData: object,\n  bookingDates: shape({\n    bookingStart: instanceOf(Date).isRequired,\n    bookingEnd: instanceOf(Date).isRequired,\n  }),\n  fetchStripeCustomer: func.isRequired,\n  stripeCustomerFetched: bool.isRequired,\n  fetchSpeculatedTransaction: func.isRequired,\n  speculateTransactionInProgress: bool.isRequired,\n  speculateTransactionError: propTypes.error,\n  speculatedTransaction: propTypes.transaction,\n  transaction: propTypes.transaction,\n  currentUser: propTypes.currentUser,\n  params: shape({\n    id: string,\n    slug: string,\n  }).isRequired,\n  onConfirmPayment: func.isRequired,\n  onInitiateOrder: func.isRequired,\n  onConfirmCardPayment: func.isRequired,\n  onRetrievePaymentIntent: func.isRequired,\n  onSavePaymentMethod: func.isRequired,\n  onSendMessage: func.isRequired,\n  initiateOrderError: propTypes.error,\n  confirmPaymentError: propTypes.error,\n  // confirmCardPaymentError comes from Stripe so that's why we can't expect it to be in a specific form\n  confirmCardPaymentError: oneOfType([propTypes.error, object]),\n  paymentIntent: object,\n\n  // from connect\n  dispatch: func.isRequired,\n\n  // from injectIntl\n  intl: intlShape.isRequired,\n\n  // from withRouter\n  history: shape({\n    push: func.isRequired,\n  }).isRequired,\n};\n\nconst mapStateToProps = state => {\n  const {\n    listing,\n    bookingData,\n    bookingDates,\n    stripeCustomerFetched,\n    speculateTransactionInProgress,\n    speculateTransactionError,\n    speculatedTransaction,\n    transaction,\n    initiateOrderError,\n    confirmPaymentError,\n  } = state.CheckoutPage;\n  const { currentUser } = state.user;\n  const { confirmCardPaymentError, paymentIntent, retrievePaymentIntentError } = state.stripe;\n  return {\n    scrollingDisabled: isScrollingDisabled(state),\n    currentUser,\n    stripeCustomerFetched,\n    bookingData,\n    bookingDates,\n    speculateTransactionInProgress,\n    speculateTransactionError,\n    speculatedTransaction,\n    transaction,\n    listing,\n    initiateOrderError,\n    confirmCardPaymentError,\n    confirmPaymentError,\n    paymentIntent,\n    retrievePaymentIntentError,\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  dispatch,\n  fetchSpeculatedTransaction: (params, transactionId) =>\n    dispatch(speculateTransaction(params, transactionId)),\n  fetchStripeCustomer: () => dispatch(stripeCustomer()),\n  onInitiateOrder: (params, transactionId) => dispatch(initiateOrder(params, transactionId)),\n  onRetrievePaymentIntent: params => dispatch(retrievePaymentIntent(params)),\n  onConfirmCardPayment: params => dispatch(confirmCardPayment(params)),\n  onConfirmPayment: params => dispatch(confirmPayment(params)),\n  onSendMessage: params => dispatch(sendMessage(params)),\n  onSavePaymentMethod: (stripeCustomer, stripePaymentMethodId) =>\n    dispatch(savePaymentMethod(stripeCustomer, stripePaymentMethodId)),\n});\n\nconst CheckoutPage = compose(\n  withRouter,\n  connect(\n    mapStateToProps,\n    mapDispatchToProps\n  ),\n  injectIntl\n)(CheckoutPageComponent);\n\nCheckoutPage.setInitialValues = (initialValues, saveToSessionStorage = false) => {\n  if (saveToSessionStorage) {\n    const { listing, bookingData, bookingDates } = initialValues;\n    storeData(bookingData, bookingDates, listing, null, STORAGE_KEY);\n  }\n\n  return setInitialValues(initialValues);\n};\n\nCheckoutPage.displayName = 'CheckoutPage';\n\nexport default CheckoutPage;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"topbar\":\"CheckoutPage_topbar__1zpY4\",\"home\":\"CheckoutPage_home__2r1iY\",\"logoMobile\":\"CheckoutPage_logoMobile__3tTtw\",\"logoDesktop\":\"CheckoutPage_logoDesktop__3vNdq\",\"contentContainer\":\"CheckoutPage_contentContainer__2e9aD\",\"bookListingContainer\":\"CheckoutPage_bookListingContainer__G2qY_\",\"aspectWrapper\":\"CheckoutPage_aspectWrapper__EUNTH\",\"rootForImage\":\"CheckoutPage_rootForImage__PyyiQ\",\"avatarWrapper\":\"CheckoutPage_avatarWrapper__1c4UD\",\"avatarMobile\":\"CheckoutPage_avatarMobile__dW-28\",\"heading\":\"CheckoutPage_heading__Wmk_3\",\"title\":\"CheckoutPage_title__DKpNd\",\"author\":\"CheckoutPage_author__ws2XJ\",\"priceBreakdownContainer\":\"CheckoutPage_priceBreakdownContainer__1vQmV\",\"priceBreakdownTitle\":\"CheckoutPage_priceBreakdownTitle__2AzWv\",\"paymentContainer\":\"CheckoutPage_paymentContainer__1PxFQ\",\"orderError\":\"CheckoutPage_orderError__2WKny\",\"notFoundError\":\"CheckoutPage_notFoundError__1gqCg\",\"speculateError\":\"CheckoutPage_speculateError__26a6-\",\"paymentForm\":\"CheckoutPage_paymentForm__3wI8C\",\"detailsContainerDesktop\":\"CheckoutPage_detailsContainerDesktop__XPaXD\",\"detailsAspectWrapper\":\"CheckoutPage_detailsAspectWrapper__OwnB1\",\"detailsHeadings\":\"CheckoutPage_detailsHeadings__1zRBN\",\"detailsTitle\":\"CheckoutPage_detailsTitle__3rfU8\",\"detailsSubtitle\":\"CheckoutPage_detailsSubtitle__2RTY5\",\"bookingBreakdownTitle\":\"CheckoutPage_bookingBreakdownTitle__2tV27\",\"bookingBreakdown\":\"CheckoutPage_bookingBreakdown__pzZRH\"};"],"sourceRoot":""}